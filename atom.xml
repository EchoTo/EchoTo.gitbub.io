<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShanTianQi&#39;s Blog</title>
  
  
  <link href="https://www.stq555.com/atom.xml" rel="self"/>
  
  <link href="https://www.stq555.com/"/>
  <updated>2022-01-11T15:14:55.318Z</updated>
  <id>https://www.stq555.com/</id>
  
  <author>
    <name>ShanTianQi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程</title>
    <link href="https://www.stq555.com/2022/01/11/%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.stq555.com/2022/01/11/%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-01-11T14:33:11.000Z</published>
    <updated>2022-01-11T15:14:55.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><hr><h1 id="第一章-多线程"><a href="#第一章-多线程" class="headerlink" title="第一章 多线程"></a>第一章 多线程</h1><p>学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那么现在详设计一个程序，边打游戏边听歌，要解决这个问题，就需要使用多进程或多线程</p><hr><h2 id="1-1并发与并行"><a href="#1-1并发与并行" class="headerlink" title="1.1并发与并行"></a>1.1并发与并行</h2><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li><li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生。</li></ul><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210708223907.png"></p><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210708224345.png"></p><blockquote><p>注意：单核处理器的计算机肯定是不能并行处理多个任务的，只能是多个任务在单个CPU上并发运行。同理，线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p></blockquote><hr><h2 id="1-2线程与进程"><a href="#1-2线程与进程" class="headerlink" title="1.2线程与进程"></a>1.2线程与进程</h2><ul><li><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li></ul><p><strong>进入到内存的程序叫进程</strong></p><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210708231151.png"></p><ul><li><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</li></ul><p><strong>应用程序到CPU的执行路径叫做线程</strong></p><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210708232046.png"></p><blockquote><p>tips：一个程序运行后至少有一个进程，一个进程可以包含多个线程</p></blockquote><p><strong>线程调度</strong></p><ul><li><p>分时调度</p><p>所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。</p></li></ul><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210708235938.png"></p><ul><li><p>抢先式调度</p><p>优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p></li></ul><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210709000000.png"></p><p><strong>主线程</strong></p><p>执行main方法的线程</p><p>单线程程序：java程序中只有一个线程</p><p>执行从main方法开始，从上到下依次执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01MainThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1=<span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        p1.run();</span><br><span class="line"></span><br><span class="line">        Person p2=<span class="keyword">new</span> Person(<span class="string">&quot;小林&quot;</span>);</span><br><span class="line">        p2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210709105448.png"></p><hr><h2 id="1-3创建线程方式一"><a href="#1-3创建线程方式一" class="headerlink" title="1.3创建线程方式一"></a>1.3创建线程方式一</h2><hr><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。</p><p><strong>第一种方法</strong>：Java中通过<strong>继承Thread类</strong>来创建并启动多线程的步骤如下：</p><ul><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务，因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ul><p>void start()使该线程开始执行；java虚拟机调用该线程的run方法。结果是两个线程并发的运行，当前线程(main方法)和另一个线程(创建的新线程，执行其run方法)。多次启动一个线程是非法的，特别是当前线程已经结束执行后，不能再重新启动，java程序属于抢占式调度，哪个线程的优先级高，哪个线程就优先执行，同一优先级，随机选择一个执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MyThread mt=<span class="keyword">new</span> MyThread();</span><br><span class="line">      mt.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="第二章-线程"><a href="#第二章-线程" class="headerlink" title="第二章 线程"></a>第二章 线程</h1><hr><h2 id="2-1多线程原理"><a href="#2-1多线程原理" class="headerlink" title="2.1多线程原理"></a>2.1多线程原理</h2><p><strong>1.随机性打印结果</strong></p><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210709111740.png"></p><p><strong>2.多线程内存图解</strong></p><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210809181832.png"></p><hr><h2 id="2-2Thread类"><a href="#2-2Thread类" class="headerlink" title="2.2Thread类"></a>2.2Thread类</h2><p><strong>构造方法：</strong></p><ul><li><code>public Thread()</code>：分配一个新的线程对象。</li><li><code>public Thread(String name)</code>：分配一个指定名字的新的线程对象。</li><li><code>public Thread(Runnable target)</code>：分配一个带有指定目标的新的线程对象。</li><li><code>public Thread(Runnable target,String name)</code>：分配一个带有指定目标的并指定名字的新的线程对象。</li></ul><p><strong>常用方法：</strong></p><ul><li><code>public String getName()</code>：获取当前线程名称。</li><li><code>public void start()</code>：导致此线程开始执行；Java虚拟机调用此线程的run方法。</li><li><code>public void run()</code>：此线程要执行的任务在此处定义代码。</li><li><code>public static void sleep(long millis)</code>：使当前正在执行的线程以指定的毫秒数暂停(暂时停止执行)。</li><li><code>public static Thread currentThread()</code>：返回对当前正在执行的线程对象的引用</li></ul><p><strong>1.获取当前线程名称</strong></p><ul><li>使用Thread类中的方法getName()<br>String getName()返回该线程的名称。</li><li>可以先获取到当前正在执行的线程,使用线程中的方法getName()获取线程的名称<br>static Thread currentThread(）返回对当前正在执行的线程对象的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread2 mt=<span class="keyword">new</span> MyThread2();</span><br><span class="line">        mt.start();<span class="comment">//Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方法</span></span><br><span class="line"><span class="comment">//        String name = getName();</span></span><br><span class="line"><span class="comment">//        System.out.println(name);</span></span><br><span class="line">        <span class="comment">//第二种方法</span></span><br><span class="line"><span class="comment">//        Thread thread = Thread.currentThread();</span></span><br><span class="line"><span class="comment">//        String name = thread.getName();</span></span><br><span class="line"><span class="comment">//        System.out.println(name);</span></span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.设置线程的名称:(了解)</strong></p><ul><li>使用Thread类中的方法setName(名字)<br>void setName ( String name）改变线程名称，使之与参数name 相同。</li><li>创建一个带参数的构造方法，参数传递线程的名称;调用父类的带参构造方法,把线程名称传递给父类,让父类(Thread)给子线程起一个名字<br>Thread ( String name)分配新的 Thread 对象。</li></ul><p><strong>3.sleep</strong></p><p><code>public static void sleep(long millis)</code>：使当前正在执行的线程以指定的毫秒数暂停(暂时停止执行)。毫秒数结束后，线程继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Sleep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟秒表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">60</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="comment">//使用Thread类的sleep方法让程序睡眠1秒钟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3创建线程方式二"><a href="#2-3创建线程方式二" class="headerlink" title="2.3创建线程方式二"></a>2.3创建线程方式二</h2><p>采用<code>java.lang.Runnable</code>，我们只需要重写run方法即可。</p><p>步骤：</p><ul><li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li><li>调用线程对象的start()方法来启动线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            RunnableImpl run =<span class="keyword">new</span> RunnableImpl();</span><br><span class="line">            Thread t =<span class="keyword">new</span> Thread(run);</span><br><span class="line">            t.start();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-4Thread和Runnable的区别"><a href="#2-4Thread和Runnable的区别" class="headerlink" title="2.4Thread和Runnable的区别"></a>2.4Thread和Runnable的区别</h2><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runnable接口的话，则很容易实现资源共享。</p><p><strong>总结：</strong></p><p><strong>实现Runnable接口比继承Thread类所具有的优势：</strong></p><p>1.适合多个相同的程序代码的线程去共享同一个资源。</p><p>2.可以避免Java中的单继承的局限性。</p><p>3.增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</p><p>4.线程池只能放入实现Runnable或Callable类线程，不能直接放入继承Thread的类。</p><blockquote><p>扩充：在Java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用Java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实就是在操作系统中启动了一个进程。</p></blockquote><hr><h2 id="2-5匿名内部类方式实现线程的创建"><a href="#2-5匿名内部类方式实现线程的创建" class="headerlink" title="2.5匿名内部类方式实现线程的创建"></a>2.5匿名内部类方式实现线程的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06InnerClassThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程的父类是Thread</span></span><br><span class="line">        <span class="comment">//new MyThread().start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">//线程的接口Runnable</span></span><br><span class="line">        <span class="comment">//Runnable r =new RunnableImpl();//多态</span></span><br><span class="line">        Runnable t=<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="comment">//重写run方法，设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">       <span class="keyword">new</span> Thread(t).start();</span><br><span class="line">       <span class="comment">//简化接口的方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="第三章-线程安全"><a href="#第三章-线程安全" class="headerlink" title="第三章    线程安全"></a>第三章    线程安全</h1><hr><h2 id="3-1线程安全"><a href="#3-1线程安全" class="headerlink" title="3.1线程安全"></a>3.1线程安全</h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><p>我们通过一个案例，演示线程的安全问题:</p><p>电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是”“战狼三”，本次电影的座位共100个(本场电影只能卖100张票)。</p><p>我们来模拟电影院的售票窗口，实现多个窗口同时卖“葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票)</p><p>需要窗口，采用线程对象来模拟;需要票，Runnable接口子类来模拟</p><p>模拟票︰</p><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210810131523.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo06.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      RunnableImpl mt =<span class="keyword">new</span> RunnableImpl();</span><br><span class="line">      Thread t0 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      Thread t1 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      Thread t2 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      t0.start();</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo07.Synchronized;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   解决线程安全问题的第一种方案：使用同步代码块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个多个线程共享的票源</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//     设置线程任务：卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        使用死循环，让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//            先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//提高安全问题出现的概率，让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;正在卖第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>卖票案例出现了线程安全问题，卖出了不存在的票和重复的票。</p><hr><h2 id="3-2线程同步"><a href="#3-2线程同步" class="headerlink" title="3.2线程同步"></a>3.2线程同步</h2><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。</p><p>要解决上述多线程并发访问一个资源的安全性问题：也就是解决重复票与不存在票问题，Java提供了同步机制(<strong>synchronized</strong>)来解决。</p><p>根据案例简述︰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">窗口<span class="number">1</span>线程进入操作的时候，窗口<span class="number">2</span>和窗口<span class="number">3</span>线程只能在外等着，窗口<span class="number">1</span>操作结束，窗口<span class="number">1</span>和窗口<span class="number">2</span>和窗口<span class="number">3</span>才有机会进入代码去执行。也就是说在某个钱程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</span><br></pre></td></tr></table></figure><p>有三种方式完成同步操作：</p><ul><li>同步代码块</li><li>同步方法</li><li>锁机制</li></ul><hr><h2 id="3-3同步代码块"><a href="#3-3同步代码块" class="headerlink" title="3.3同步代码块"></a>3.3同步代码块</h2><ul><li><strong>同步代码块</strong>：<code>synchronized</code>关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li></ul><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">    需要同步操作的代码(访问了共享数据的代码)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步锁</strong></p><p>对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。</p><p>1.锁对象 可以是任意类型。</p><p>2.多个线程对象 要使用同一把锁。</p><p>3.锁对象作用：把同步代码块锁住，只让一个线程在同步代码块中执行。</p><blockquote><p>注意：在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就能进入代码块，其他的线程只能在外等着(BLOCKED)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo07.Synchronized;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      RunnableImpl mt =<span class="keyword">new</span> RunnableImpl();</span><br><span class="line">      Thread t0 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      Thread t1 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      Thread t2 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      t0.start();</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo07.Synchronized;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   解决线程安全问题的第一种方案：使用同步代码块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个多个线程共享的票源</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line">     Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//     设置线程任务：卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        使用死循环，让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            <span class="comment">//            先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//提高安全问题出现的概率，让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;正在卖第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>原理</strong></p><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210810164723.png"></p><hr><h2 id="3-4同步方法"><a href="#3-4同步方法" class="headerlink" title="3.4同步方法"></a>3.4同步方法</h2><ul><li><strong>同步方法</strong>：使用synchronized修饰的方法，就叫做同步方法，保证A线程执行该方法的时候，其他线程只能在方法外等着。</li></ul><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同步锁是Who？</p><ul><li>对于非static方法，同步锁就是this</li><li>对于static方法，静态方法的锁对象是本类的class属性—&gt;calss文件对象(反射)</li></ul></blockquote><p>1.非静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo08.Synchronized;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      RunnableImpl mt =<span class="keyword">new</span> RunnableImpl();</span><br><span class="line">      Thread t0 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      Thread t1 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      Thread t2 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      t0.start();</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo08.Synchronized;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    解决线程安全问题的第二种方案：使用同步方法</span></span><br><span class="line"><span class="comment">    步骤：</span></span><br><span class="line"><span class="comment">        1.把访问了共享数据的代码抽取出来，放到一个方法中</span></span><br><span class="line"><span class="comment">        2.在方法上添加synchronized修饰符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            payTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">payTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;正在卖第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo08.Synchronized;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      RunnableImpl mt =<span class="keyword">new</span> RunnableImpl();</span><br><span class="line">      Thread t0 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      Thread t1 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      Thread t2 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      t0.start();</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo08.Synchronized;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    解决线程安全问题的第二种方案：使用同步方法</span></span><br><span class="line"><span class="comment">    步骤：</span></span><br><span class="line"><span class="comment">        1.把访问了共享数据的代码抽取出来，放到一个方法中</span></span><br><span class="line"><span class="comment">        2.在方法上添加synchronized修饰符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            payTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">payTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(RunnableImpl.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;正在卖第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-5Lock锁"><a href="#3-5Lock锁" class="headerlink" title="3.5Lock锁"></a>3.5Lock锁</h2><p><code>java.util.concurrent.locks.Lock</code>机制提供了比<strong>synchronized</strong>代码块和<strong>synchronized</strong>方法更广泛的锁定操作，同步代码块/同步方法具有的功能Lock都有，除此之外更强大，更体现面向对象。</p><p>Lock锁也称同步锁，加锁与释放锁方法：</p><ul><li><code>public void lock()</code>：加同步锁</li><li><code>public void unlock()</code>：释放同步锁</li></ul><p>java.util.concurrent.locks.ReentrantLock impLements Lock接口</p><p><strong>使用步骤:</strong></p><ul><li>在成员位置创建一个ReentrantLock对象</li><li>在可能会出现安全问题的代码前调用Lock接口中的方法Lock获取锁</li><li>在可能会出现安全问题的代码后调用Lock接口中的方法unLock释放锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo09.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      RunnableImpl mt =<span class="keyword">new</span> RunnableImpl();</span><br><span class="line">      Thread t0 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      Thread t1 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      Thread t2 =<span class="keyword">new</span> Thread(mt);</span><br><span class="line">      t0.start();</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo09.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 解决线程安全问题的第三种方案：使用Lock锁</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//1.在成员位置创建一个ReentrantLock对象</span></span><br><span class="line">    Lock l =<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            l.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;正在卖第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    l.unlock();<span class="comment">//无论程序是否异常，都会把锁释放</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="第四章-线程状态"><a href="#第四章-线程状态" class="headerlink" title="第四章    线程状态"></a>第四章    线程状态</h1><hr><h2 id="4-1线程状态概述"><a href="#4-1线程状态概述" class="headerlink" title="4.1线程状态概述"></a>4.1线程状态概述</h2><p>当线程被创建并启用后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。</p><p>在线程的生命周期中，API中<code>java.lang.Thread.State</code>这个枚举中给出了六种线程状态：</p><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210810174734.png"></p><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210810174638.png"></p><hr><h2 id="4-2Timed-Waiting-计时等待"><a href="#4-2Timed-Waiting-计时等待" class="headerlink" title="4.2Timed Waiting(计时等待)"></a>4.2Timed Waiting(计时等待)</h2><p><strong>倒计时</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo05.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Sleep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟秒表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">60</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="comment">//使用Thread类的sleep方法让程序睡眠1秒钟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入TIMED_WAITING状态的一种常见情形是调用sleep方法，单独的线程也可以调用，不一定非要有协作关系。</li><li>为了让其他的线程有机会执行，可以将Thread.sleep()的调用<strong>放在线程run()之内</strong>。这样才能保证该线程执行过程中会睡眠。</li><li>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable(可运行)状态。</li></ul><blockquote><p>tips：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。</p></blockquote><p>Timed Waiting线程状态图：</p><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210810174841.png"></p><hr><h2 id="4-3BLOCKED-锁阻塞"><a href="#4-3BLOCKED-锁阻塞" class="headerlink" title="4.3BLOCKED(锁阻塞)"></a>4.3BLOCKED(锁阻塞)</h2><p>Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁(锁对象)的线程处于这一状态。</p><p>如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</p><p>这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态。</p><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210810175943.png"></p><hr><h2 id="4-4Waiting-无限等待"><a href="#4-4Waiting-无限等待" class="headerlink" title="4.4Waiting(无限等待)"></a>4.4Waiting(无限等待)</h2><p>Waiting状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的(唤醒)动作的线程处于这一状态。</p><p>Runnable—wait()—&gt;Waiting—notify()—&gt;Runnable</p><p><strong>等待唤醒案例:线程之间的通信</strong><br>        创建一个顾客线程(消费者):告知老板要的包子的种类和数量,调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)</p><p>​        创建一个老板线程(生产者):花了5秒做包子,做好包子之后,调用notify方法,唤醒顾客吃包子</p><p>注意:<br>       顾客和老板线程必须使用同步代码块包裹起来,保证等待和唤醒只能有一个在执行</p><p>​       同步使用的锁对象必须保证唯—<br>​       只有锁对象才能调用wait和notify方法</p><p>Obejct类中的方法<br>void wait()<br>         在其他线程调用此对象的notify()方法或notifyAll()方法前，导致当前线程等待。</p><p>void notify()<br>         唤醒在此对象监视器上等待的单个线程。</p><p>​         会继续执行wait方法之后的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo10WaitAndNotify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj =<span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;告知老板要的包子的种类和数量&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            obj.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//唤醒之后的代码</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;开吃！&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">          <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line">                          Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                          e.printStackTrace();</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                          System.out.println(<span class="string">&quot;老板5秒钟之后做好包子，告知顾客，可以吃包子了&quot;</span>);</span><br><span class="line">                          obj.notify();</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进入到Timelwaiting (计时等待)有两种方式</strong></p><ul><li>使用sleep(Long m)方法,在毫秒值结束之后,线程睡醒进入到RunnablLe/BLocked状态</li><li>使用wait(Long m)方法, wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来，线程睡醒进入到Runmable/Blocked状态</li></ul><p><strong>唤醒的方法:</strong></p><ul><li>void notify()：唤醒在此对象监视器上等待的单个线程。</li><li>void notifyAll()：唤醒在此对象监视器上等待的所有线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo10WaitAndNotify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj =<span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客1告知老板要的包子的种类和数量&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//唤醒之后的代码</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客1开吃！&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客2告知老板要的包子的种类和数量&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//唤醒之后的代码</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客2开吃！&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;老板5秒钟之后做好包子，告知顾客，可以吃包子了&quot;</span>);</span><br><span class="line"><span class="comment">//                        obj.notify();//如果有多个等待线程，随机唤醒一个</span></span><br><span class="line">                          obj.notifyAll();<span class="comment">//全部唤醒</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="第五章-等待唤醒机制"><a href="#第五章-等待唤醒机制" class="headerlink" title="第五章    等待唤醒机制"></a>第五章    等待唤醒机制</h1><hr><h2 id="5-1线程间通讯"><a href="#5-1线程间通讯" class="headerlink" title="5.1线程间通讯"></a>5.1线程间通讯</h2><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作(线程的任务)却不相同。</p><p>比如：线程A用来生产商品，线程B用来购买商品，商品可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p><p><strong>为什么要处理线程间通信：</strong></p><p>多个线程并发执行时，在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务时，并且我们希望他们有规律的执行，那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p><p><strong>如何保证线程间通信有效利用资源：</strong></p><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。就是多个线程在操作同一份数据时，避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即–<strong>等待唤醒机制</strong>。</p><hr><h2 id="5-2等待唤醒机制"><a href="#5-2等待唤醒机制" class="headerlink" title="5.2等待唤醒机制"></a>5.2等待唤醒机制</h2><p><strong>什么是等待唤醒机制</strong><br>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的**竞争 ( race )**，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。</p><p>就是在一个线程进行了规定操作后，就进入等待状态 ( <strong>wait()</strong>)，等待其他线程执行完他们的指定代码过后再将其唤醒( <strong>notify()</strong>) ;在有多个线程进行等待时，如果需要，可以使用**notifyAll()**来唤醒所有的等待线程。</p><p>wait/notify 就是线程间的一种协作机制。</p><p><strong>等待唤醒中的方法</strong><br>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下︰</p><ul><li>wait :线程不再活动，不再参与调度，进入wait set中，因此不会浪费CPU资源，也不会去竞争锁了，这时的线程状态即是WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是”<strong>通知( notify )</strong> “在这个对象上等待的线程队wait set中释放出来，重新进入到调度队列( ready queue )中</li><li>notify :则选取所通知对象的wait set中的一个线程释放;唤醒等待时间最长的那个线程。</li><li>notifyAll:则释放所通知对象的wait set 上的全部线程。</li></ul><blockquote><p>tips：哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁(很可能面临其它线程的竞争），成功后才能在当初调用wait方法之后的地方恢复执行。</p><p>总结：</p><ul><li>如果能获取锁，线程就从WAITING状态变成RUNNABLE状态</li><li>否则，总wait set 出来，又进入entry set，线程就从WAITING状态又变成BLOCKED状态</li></ul></blockquote><p><strong>调用wait和notify方法需要注意的细节</strong></p><ul><li>wait方法与notify方法必须要由同一个锁对象调用。因为∶对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li><li>wait方法与notify方法是属于Object类的方法的。因为︰锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li><li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为∶必须要通过锁对象调用这2个方法。</li></ul><hr><h2 id="5-3生产者与消费者问题"><a href="#5-3生产者与消费者问题" class="headerlink" title="5.3生产者与消费者问题"></a>5.3生产者与消费者问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo11case;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     shangPin sp=<span class="keyword">new</span> shangPin();</span><br><span class="line">     <span class="keyword">new</span> ThreadA(sp).start();</span><br><span class="line">     <span class="keyword">new</span> ThreadB(sp).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo11case;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shangPin</span> </span>&#123;</span><br><span class="line">    String goods;</span><br><span class="line">    String box;</span><br><span class="line">    <span class="keyword">boolean</span> flag =<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo11case;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> shangPin sp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(shangPin sp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sp=sp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (sp)&#123;</span><br><span class="line">                <span class="keyword">if</span> (sp.flag=<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sp.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    sp.goods=<span class="string">&quot;aj1&quot;</span>;</span><br><span class="line">                    sp.box=<span class="string">&quot;塑料盒&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    sp.goods=<span class="string">&quot;af1&quot;</span>;</span><br><span class="line">                    sp.box=<span class="string">&quot;纸盒&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">&quot;ThreadA正在生产&quot;</span>+sp.goods+sp.box);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                sp.flag=<span class="keyword">true</span>;</span><br><span class="line">                sp.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;ThreadA已经生产好了&quot;</span>+sp.goods+sp.box+<span class="string">&quot;ThreadB可以开始购买了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo11case;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> shangPin sp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(shangPin sp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sp=sp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (sp)&#123;</span><br><span class="line">                <span class="keyword">if</span> (sp.flag=<span class="keyword">false</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sp.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;ThreadB正在购买：&quot;</span>+sp.goods+sp.box+<span class="string">&quot;商品&quot;</span>);</span><br><span class="line">                sp.flag=<span class="keyword">false</span>;</span><br><span class="line">                sp.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;ThreadB已经把：&quot;</span>+sp.goods+sp.box+<span class="string">&quot;商品购买完了，ThreadA开始生产商品&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;----------------------------------------------------------------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="第六章-线程池"><a href="#第六章-线程池" class="headerlink" title="第六章    线程池"></a>第六章    线程池</h1><hr><h2 id="6-1线程池思想概述"><a href="#6-1线程池思想概述" class="headerlink" title="6.1线程池思想概述"></a>6.1线程池思想概述</h2><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210810212906.png"></p><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题:</p><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务?</p><p>在Java中可以通过线程池来达到这样的效果。</p><hr><h2 id="6-2线程池概念"><a href="#6-2线程池概念" class="headerlink" title="6.2线程池概念"></a>6.2线程池概念</h2><ul><li><strong>线程池</strong>：其实就是一个容纳多个线程的容器，其中的线程可以重复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li></ul><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210810214141.png"></p><p>线程池工作原理图：</p><p><img src="https://gitee.com/are-you-a-cookie/cloudimages/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210810214223.png"></p><p>合理利用线程池能够带来三个好处：</p><ul><li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li></ul><hr><h2 id="6-3线程池的使用"><a href="#6-3线程池的使用" class="headerlink" title="6.3线程池的使用"></a>6.3线程池的使用</h2><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p><p>Executors类中有创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池，也就是池中的线程个数可以指定最大数量)</li></ul><p>获取到了一个线程池ExecutorService对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下:</p><ul><li><code>public Future&lt;?&gt; submit(Runnable task)</code>：获取线程池中的某一个线程对象，并执行。</li></ul><blockquote><p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p></blockquote><p>使用线程池中线程对象的步骤：</p><p>1.创建线程池对象。</p><p>2.创建Runnable接口子类对象。(task)</p><p>3.提交Runnable接口子类对象。(take task)</p><p>4.关闭线程池(一般不做)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo12ThreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">        executorService.shutdown();<span class="comment">//不建议执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.indi.demo12ThreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;创建了一个新的线程执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;第一章-多线程&quot;&gt;&lt;a href=&quot;#第一章-多线程&quot; class=&quot;headerlink&quot; title=&quot;第一章 多线</summary>
      
    
    
    
    <category term="java" scheme="https://www.stq555.com/categories/java/"/>
    
    
    <category term="java" scheme="https://www.stq555.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="https://www.stq555.com/2022/01/11/%E9%9B%86%E5%90%88/"/>
    <id>https://www.stq555.com/2022/01/11/%E9%9B%86%E5%90%88/</id>
    <published>2022-01-11T04:17:54.000Z</published>
    <updated>2022-01-11T14:29:10.639Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="第一章-Collection集合-单列集合"><a href="#第一章-Collection集合-单列集合" class="headerlink" title="第一章 Collection集合(单列集合)"></a>第一章 Collection集合(单列集合)</h1><h2 id="1-1集合概述"><a href="#1-1集合概述" class="headerlink" title="1.1集合概述"></a>1.1集合概述</h2><hr><ul><li>集合：集合是Java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组的区别：</p><p>1.数组的长度是固定的。</p><p>   集合的长度是可变的。</p><p>2.数组中存储的是同一种元素，可以存储基本类型数据值。</p><p>   集合存储的都是对象，而且对象的类型可以不一致，在开发中一般当对象多的时候，使用集合进行存储。</p><hr><h2 id="1-2集合框架"><a href="#1-2集合框架" class="headerlink" title="1.2集合框架"></a>1.2集合框架</h2><hr><p>集合按照其存储结构可以分为两大类：分别是==单列集合==<strong>(java.util.Collection)<strong>和==双列集合==</strong>(java.util.Map)</strong></p><ul><li><strong>Collection</strong>:单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<strong>java.util.List</strong>和<strong>java.util.Set</strong>，其中List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有<strong>java.util.ArrayList</strong>和<strong>java.util.LinkedList</strong>，Set接口的主要实现类有<strong>java.util.HashSet</strong>和<strong>java.util.TreeSet</strong></li></ul><p><img src="https://s2.loli.net/2022/01/11/kJzBVUpWIOrX4Z8.png"></p><ul><li>橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类</li><li>集合本身是一个工具，它存放在java.util包中。在<strong>Collection</strong>接口定义着单列集合框架中最最共性的内容</li></ul><p><img src="https://s2.loli.net/2022/01/11/OlFna5j4kIuobPi.png"></p><h2 id="1-3Collection常用功能"><a href="#1-3Collection常用功能" class="headerlink" title="1.3Collection常用功能"></a><strong>1.3Collection常用功能</strong></h2><hr><p><strong>Collection</strong>是所有单列集合的父接口，因此在<strong>Collection</strong>中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。</p><ul><li><p>public boolean add(E e)：把给定的对象添加到当前集合中</p></li><li><p>public void clear()：清空集合中所有的元素</p></li><li><p>public boolean remove(E e)：把给定的对象在当前集合中删除</p></li><li><p>public boolean contains(E e)：判断当前集合中是否包含给定的对象</p></li><li><p>public boolean isEmpty()：判断当前集合是否为空</p></li><li><p>public int size()：返回集合中元素的个数</p></li><li><p>public object[ ] toArray()：把集合中的元素，存储到数组中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Rosyday01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rosy10Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; coll=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(coll);<span class="comment">//重写了toString方法 []</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.public boolean add(E e)：把给定的对象添加到当前集合中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> b1=coll.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;田七&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;孙八&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;b1:&quot;</span>+b1);<span class="comment">//b1:true</span></span><br><span class="line">        System.out.println(coll);<span class="comment">//[张三, 李四, 王五, 赵六, 田七, 孙八]</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        2.public boolean remove(E e)：把给定的对象在当前集合中删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> b2=coll.remove(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;b2:&quot;</span>+b2);<span class="comment">//b2:true</span></span><br><span class="line">        System.out.println(coll);<span class="comment">//[李四, 王五, 赵六, 田七, 孙八]</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3.public boolean contains(E e)：判断当前集合中是否包含给定的对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> b3=coll.contains(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;b3:&quot;</span>+b3);<span class="comment">//b3:true</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        4.public int size()：返回集合中元素的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> b4=coll.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;集合中元素的个数是：&quot;</span>+b4);<span class="comment">//集合中元素的个数是：5</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        5.public boolean isEmpty()：判断当前集合是否为空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> b5=coll.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">&quot;b5:&quot;</span>+b5);<span class="comment">//b5:false</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        6.public object[ ] toArray()：把集合中的元素，存储到数组中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object[] arr = coll.toArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        7.public void clear()：清空集合中所有的元素，但集合还在</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        coll.clear();</span><br><span class="line">        System.out.println(coll);<span class="comment">//[]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h1><hr><h2 id="2-1Iterator接口"><a href="#2-1Iterator接口" class="headerlink" title="2.1Iterator接口"></a>2.1Iterator接口</h2><hr><p>​     在程序开发中，要遍历集合中的所有元素，jdk专门提供了一个接口<strong>java.util,Iterator</strong>。<strong>Colection</strong>和<strong>Map</strong>接口主要用于存储数据，而<strong>Iterator</strong>接口主要用于迭代访问(即遍历)<strong>Colection</strong>中的元素，因此<strong>Iterator</strong>对象也被称作迭代器。</p><p>  1.获取迭代器的方法：</p><ul><li><p>**public Iterator iterator( )**：获取集合对应的迭代器，用于遍历集合中的元素</p><p>2.迭代的概念：</p></li><li><p><strong>迭代</strong>：即<strong>Collection</strong>集合元素的通用获取方法。在取元素之前要判断集合中有没有元素，如果有就把这个元素取出来，继续再判断，如果还有就再取出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p></li></ul><p>​    3.<strong>Iterator</strong>接口的常用方法如下：</p><ul><li>**public E next( )**：返回迭代的下一个元素</li><li>**public boolean hasNext( )**：如果仍有元素可以迭代，则返回true</li></ul><p>​    4.迭代器的使用步骤(==重点==)：</p><p>​        1.使用集合中的方法iterator( )获取迭代器的实现类对象，使用Iterator接口接收(多态)</p><p>​        2.使用Iterator接口中的方法hasNext判断还有没有下一个元素</p><p>​        3.使用Iterator接口中的方法next取出集合中的下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt;coll=<span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//使用多态方式创建对象</span></span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">&quot;叽叽叽&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;啦啦啦&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;略略略&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;啧啧啧&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;呵呵呵&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator=coll.iterator();</span><br><span class="line">        <span class="comment">// 1.使用集合中的方法iterator( )获取迭代器的实现类对象，使用Iterator接口接收(多态)</span></span><br><span class="line">        <span class="comment">//注意:Iterator&lt;E&gt;接口也是有泛型的，泛型的类型跟集合泛型的类型保持一致</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;<span class="comment">//2.使用Iterator接口中的方法hasNext判断还有没有下一个元素</span></span><br><span class="line">            System.out.println(iterator.next());<span class="comment">//3.使用Iterator接口中的方法next取出集合中的下一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2迭代器的实现原理"><a href="#2-2迭代器的实现原理" class="headerlink" title="2.2迭代器的实现原理"></a>2.2迭代器的实现原理</h2><hr><ul><li><p>java.util.Iterator接口：迭代器(对集合进行遍历)</p><pre><code>1.boolean hasNext() 如果仍有元素可以迭代，则返回true，没有返回false2.E next() 返回迭代的下一个元素                 取出集合中的下一个元素</code></pre><p> Iterator迭代器，是一个接口，我们无法直接使用，需要使用Iterator接口的实现类对象，获取实现类的方法比较特殊<br> Collection接口中有一个方法，叫iterator(),这个方法返回的就是迭代器的实现类对象</p><pre><code> Iterator&lt;E&gt; iterator() 返回在此 collection的元素上进行迭代的迭代器</code></pre></li><li><p>当没有元素可取时，<strong>iterator.hasNext()<strong>返回值为false，再输出</strong>iterator.next()<strong>时程序会报错，显示</strong>Exception in thread “main” java.util.NoSuchElementException</strong>，==NoSuchElementException没有元素异常==</p></li><li><p>Iterator<String> iterator===coll.iterator();==高亮部分是实现类对象，获取迭代器的实现类对象，并把指针(索引)指向集合的-1索引</p></li><li><p>iterator.next() 1.取出下一个元素</p><p>​                      2.会把指针向后移动一位</p></li></ul><h2 id="2-3增强for"><a href="#2-3增强for" class="headerlink" title="2.3增强for"></a>2.3增强for</h2><hr><p>​    增强for循环(也称for each循环)jdk1.5以后，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历过程中，不能对集合中的元素进行增删操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(集合/数组元素的数据类型  变量名：集合名/数组名)&#123;</span><br><span class="line">        <span class="comment">//写操作代码</span></span><br><span class="line">    System.out.println(变量名);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>底层使用的也是迭代器，使用for循环的格式，简化了迭代器的书写</p></li><li><p>**Collection<E>extends Iterable<E>**：所有单列集合都可以使用增强for </p><p>**public interface Iterable<T>**实现了这个接口，允许对象成为”foreach”语句的目标 </p></li></ul><h3 id="例一：遍历数组"><a href="#例一：遍历数组" class="headerlink" title="例一：遍历数组"></a>例一：遍历数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01foreach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">//使用增强for遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a:arr) &#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例二：遍历集合"><a href="#例二：遍历集合" class="headerlink" title="例二：遍历集合"></a>例二：遍历集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01foreach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; coll=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;科比&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;艾弗森&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;奥尼尔&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;姚明&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;乔丹&quot;</span>);</span><br><span class="line">        <span class="comment">//使用增强for遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String a:coll) &#123;<span class="comment">//接收变量a代表  代表被遍历到的集合元素</span></span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips：增强for循环必须有遍历的目标。目标只能是Collection集合或者数组。增强for循环仅仅作为遍历出现</p></blockquote><hr><h1 id="第三章-泛型"><a href="#第三章-泛型" class="headerlink" title="第三章 泛型"></a>第三章 泛型</h1><hr><h2 id="3-1泛型概述"><a href="#3-1泛型概述" class="headerlink" title="3.1泛型概述"></a>3.1泛型概述</h2><hr><p>​    集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升为Object类型，当我们在取出每一个对象，并进行相应的操作，这时必须采用类型转换。</p><h2 id="3-2使用泛型的好处"><a href="#3-2使用泛型的好处" class="headerlink" title="3.2使用泛型的好处"></a>3.2使用泛型的好处</h2><hr><p>  1.创建集合对象，不使用泛型</p><ul><li>好处：集合不使用泛型，默认类型就是Object类型，可以存储任意类型的数据</li><li>弊端：不安全，会引发异常</li></ul><p>观察以下代码(==创建集合对象，不使用泛型==)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Collection coll=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以在此存放</span></span><br><span class="line">        Iterator it=coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext)&#123;</span><br><span class="line">            <span class="comment">//需要打印每个字符串的长度，使用String类特有方法length获取字符串长度，就要把迭代出的对象转成String类型即向下转型</span></span><br><span class="line">            String str=(String)it.next();</span><br><span class="line">            System.out.println(str.length());<span class="comment">//会抛出ClassCastException类型转换异常，不能把Integer类型转换成String类型</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  2.==创建集合对象，使用泛型==</p><ul><li><p>好处：1.避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型</p><p>​           2.把运行期异常(代码运行之后会抛出的异常)，提升到了编译期异常(写代码的时候会报错)</p></li><li><p>弊端：泛型是什么类型，只能存储什么类型的数据</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abb&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;cdd&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator=list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            String s=iterator.next();<span class="comment">//使用泛型，不需要进行类型转换</span></span><br><span class="line">            System.out.println(s.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips：泛型是数据类型的一部分，我们将类名与泛型合并一起看作数据类型。</p></blockquote><h2 id="3-3泛型的定义与使用"><a href="#3-3泛型的定义与使用" class="headerlink" title="3.3泛型的定义与使用"></a>3.3泛型的定义与使用</h2><hr><p>​    泛型，用来灵活地将数据类型应用到不同的类，方法，接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;代表泛型的变量&gt; </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">pubilc <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型：即什么时候确定泛型。</p><p><strong>在创建对象的时候确定泛型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Generic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不写泛型默认Object类型</span></span><br><span class="line">        Name a1=<span class="keyword">new</span> Name();</span><br><span class="line">        a1.setName(<span class="number">1</span>);</span><br><span class="line">        System.out.println(a1.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Name对象，泛型使用Integer类型</span></span><br><span class="line">        Name&lt;Integer&gt; a2=<span class="keyword">new</span> Name&lt;&gt;();<span class="comment">//Integer类型</span></span><br><span class="line">        a2.setName(<span class="number">331</span>);</span><br><span class="line">        System.out.println(a2.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Name对象，泛型使用String类型</span></span><br><span class="line">        Name&lt;String&gt; a3=<span class="keyword">new</span> Name&lt;&gt;();<span class="comment">//字符串类型</span></span><br><span class="line">        a3.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        System.out.println(a3.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Name</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(E name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;   &#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show1</span><span class="params">(MVP mvp)</span></span>&#123;</span><br><span class="line">       System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">(MVP mvp)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethod it=<span class="keyword">new</span> GenericMethod();</span><br><span class="line">        it.method01(<span class="number">331</span>);</span><br><span class="line">        it.method01(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        it.method01(<span class="number">8.8</span>);</span><br><span class="line">        it.method01(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">        it.method02(<span class="string">&quot;静态方法不建议创建对象使用&quot;</span>);</span><br><span class="line">        GenericMethod.method02(<span class="number">331</span>);</span><br><span class="line">        GenericMethod.method02(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        GenericMethod.method02(<span class="string">&quot;8.8&quot;</span>);</span><br><span class="line">        GenericMethod.method02(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个含有泛型的方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;M&gt; <span class="function"><span class="keyword">void</span> <span class="title">method01</span><span class="params">(M m)</span></span>&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个含有泛型的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function"><span class="keyword">void</span> <span class="title">method02</span><span class="params">(S s)</span></span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span>接口名&lt;代表泛型的变量&gt; </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：</p><p><strong>1.定义类时确定泛型的类型</strong></p><p><strong>2.接口使用什么泛型实现类就使用什么泛型</strong></p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    测试含有泛型的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建GenericInterfaceImpl1对象</span></span><br><span class="line">        GenericInterfaceImpl1 it1=<span class="keyword">new</span> GenericInterfaceImpl1();</span><br><span class="line">        it1.method(<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">        <span class="comment">//创建GenericInterfaceImpl2对象</span></span><br><span class="line">        GenericInterfaceImpl2&lt;Integer&gt; it2=<span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        it2.method(<span class="number">331</span>);</span><br><span class="line">        GenericInterfaceImpl2&lt;Double&gt; it3=<span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        it3.method(<span class="number">8.8</span>);</span><br><span class="line">        GenericInterfaceImpl2&lt;Boolean&gt; it4=<span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        it4.method(<span class="keyword">true</span>);</span><br><span class="line">        GenericInterfaceImpl2&lt;String&gt; it5=<span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        it5.method(<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericInterface</span>&lt;<span class="title">I</span>&gt;</span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(I i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">     含有泛型的接口，第一种使用方式：定义接口的实现类，实现接口，指定接口的泛型</span></span><br><span class="line"><span class="comment">     public interface Iterator&lt;E&gt;&#123;</span></span><br><span class="line"><span class="comment">     E next();</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     Scanner类实现了Iterator接口，并指定接口的泛型为String，所以重写的next方法泛型默认就是String</span></span><br><span class="line"><span class="comment">     public final class Scanner implements Iterator&lt;String&gt;&#123;</span></span><br><span class="line"><span class="comment">           public String next() &#123; &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl1</span> <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">         System.out.println(s);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">       含有泛型的接口，第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走</span></span><br><span class="line"><span class="comment">       就相当于定义了一个含有泛型的类，创建对象的时候确定泛型的类型</span></span><br><span class="line"><span class="comment">       public interface list(E)&#123;</span></span><br><span class="line"><span class="comment">           boolean add(E e);</span></span><br><span class="line"><span class="comment">           E get(int index);</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">       public class ArrayList&lt;E&gt; implements List&lt;E&gt;&#123;</span></span><br><span class="line"><span class="comment">           public boolean add(E e) &#123; &#125;</span></span><br><span class="line"><span class="comment">           public E get(int index) &#123; &#125;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl2</span>&lt;<span class="title">I</span>&gt; <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">I</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(I i)</span> </span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4泛型通配符"><a href="#3-4泛型通配符" class="headerlink" title="3.4泛型通配符"></a>3.4泛型通配符</h2><hr><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示，但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h3 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h3><p>泛型的通配符：<strong>不知道使用什么类型来接收的时候，此时可以使用？，？表示未知通配符</strong>。？：代表任意的数据类型</p><p>此时只能接受数据，不能往该集合中存储数据。</p><ul><li>使用方式：不能创建对象使用，只能作为方法的参数使用</li></ul><blockquote><p>tips：泛型是没有继承概念的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07Generic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; a1=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        a1.add(<span class="number">3</span>);</span><br><span class="line">        a1.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; a2=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        a2.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        a2.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        printArray(a1);</span><br><span class="line">        printArray(a2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(ArrayList&lt;?&gt; list)</span></span>&#123;<span class="comment">//不知道集合里存储的是什么类型的数据时，我们使用泛型的通配符来接受数据</span></span><br><span class="line">        Iterator&lt;?&gt; iterator=list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通配符高级使用—受限泛型"><a href="#通配符高级使用—受限泛型" class="headerlink" title="通配符高级使用—受限泛型"></a>通配符高级使用—受限泛型</h3><p>在java的泛型中可以指定一个泛型的上限和下限</p><p><strong>泛型的上限</strong>：</p><ul><li>格式：<strong>类型名称 &lt;?  extends 类&gt; 对象名称</strong></li><li>意义：<strong>只能接收该类型及其子类</strong></li></ul><p><strong>泛型的下限</strong>：</p><ul><li>格式：<strong>类型名称 &lt;?  super类&gt; 对象名称</strong></li><li>意义：<strong>只能接收该类型及其父类</strong></li></ul><p>比如：现已知Object类，String类，Number类，Integer类，Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08Generic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;Integer&gt; list1=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collection&lt;String&gt; list2=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collection&lt;Number&gt; list3=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collection&lt;Object&gt; list4=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        getElement1(list1);</span><br><span class="line">        getElement1(list2);<span class="comment">//报错</span></span><br><span class="line">        getElement1(list3);</span><br><span class="line">        getElement1(list4);<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">        getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">        getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">        getElement2(list3);</span><br><span class="line">        getElement2(list4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span> <span class="params">(Collection&lt;? extends Number&gt; cool)</span></span>&#123;  &#125;</span><br><span class="line">    <span class="comment">//泛型的上限：此时的泛型？，必须是Number类型或者Number类型的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span> <span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; cool)</span></span>&#123;  &#125;</span><br><span class="line">    <span class="comment">//泛型的下限：此时的泛型？，必须是Number类型或者Number类型的父类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的继承关系：</p><p>Integer extends Number extends Object</p><p>String extends Object</p><h1 id="第四章-集合综合案例"><a href="#第四章-集合综合案例" class="headerlink" title="第四章 集合综合案例"></a>第四章 集合综合案例</h1><hr><h2 id="4-1案例介绍"><a href="#4-1案例介绍" class="headerlink" title="4.1案例介绍"></a>4.1案例介绍</h2><hr><p>按照斗地主的规则，完成发牌洗牌的动作。</p><p>具体规则：</p><p>使用54张牌打乱顺序，三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p><h2 id="4-2案例分析"><a href="#4-2案例分析" class="headerlink" title="4.2案例分析"></a>4.2案例分析</h2><hr><ul><li><p>准备牌：</p><p>牌可以设计为一个ArrayList<String>，每个字符串为一张牌。</p><p>每张牌由花色数字两部分组成，我们可以使用花色集合和数字集合嵌套迭代完成每张牌的组装。</p></li><li><p>牌由Collection类的<strong>shuffle方法</strong>进行随机排序。</p><p>使用集合工具类Collections的方法</p><p>static void shuffle(List&lt;?&gt; list)使用指定的随机源对指定列表进行置换。</p><p>会随机的打乱集合中元素的顺序</p></li><li><p>发牌：</p><p>将每个人以及底牌设计为ArrayList<String>，将最后3张牌直接存放于底牌，剩余牌通过对3取模一次发牌。</p></li><li><p>看牌：直接打印每一个集合。</p></li></ul><p><img src="https://s2.loli.net/2022/01/11/KV8BOgCljD21w4s.png"></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; poker=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String[] colors=&#123;<span class="string">&quot;♠&quot;</span>,<span class="string">&quot;♥&quot;</span>,<span class="string">&quot;♣&quot;</span>,<span class="string">&quot;♦&quot;</span> &#125;;</span><br><span class="line">        String[] numbers=&#123;<span class="string">&quot;2&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;K&quot;</span>,<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;J&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">        poker.add(<span class="string">&quot;大王&quot;</span>);</span><br><span class="line">        poker.add(<span class="string">&quot;小王&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String color:colors) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String number:numbers) &#123;</span><br><span class="line">                poker.add(color+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.shuffle(poker);</span><br><span class="line">        ArrayList&lt;String&gt; player01=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player02=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player03=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;poker.size() ; i++) &#123;</span><br><span class="line">            String s = poker.get(i);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">51</span>)&#123;</span><br><span class="line">                dipai.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                player01.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                player02.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">                player03.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩家一&quot;</span>+player01);</span><br><span class="line">        System.out.println(<span class="string">&quot;玩家二&quot;</span>+player02);</span><br><span class="line">        System.out.println(<span class="string">&quot;玩家三&quot;</span>+player03);</span><br><span class="line">        System.out.println(<span class="string">&quot;底牌&quot;</span>+dipai);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="第五章数据结构"><a href="#第五章数据结构" class="headerlink" title="第五章数据结构"></a>第五章数据结构</h1><hr><h2 id="5-1常见的数据结构"><a href="#5-1常见的数据结构" class="headerlink" title="5.1常见的数据结构"></a>5.1常见的数据结构</h2><hr><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h3><ul><li><strong>栈：stack</strong>，又称堆栈，它是运算受限的线性表，其限制是允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li></ul><p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p><ul><li>==先进后出==(即，存进去的元素，要在它后面的元素依次取出后，才能取出该元素)。</li><li>栈的入口、出口的都是栈的顶端位置。</li></ul><p><img src="https://s2.loli.net/2022/01/11/g9I8OseTiumWFMw.png"></p><h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h3><ul><li><strong>队列：queue</strong>，简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下特点：</p><ul><li>先进先出：(即，存进去的元素，要在它前面的元素依次取出后，才能取出该元素)。例如：火车进山洞</li><li>队列的入口、出口各站一侧。如下图：左侧为入口，右侧为出口。</li></ul><p><img src="https://s2.loli.net/2022/01/11/XHl4w3sdRTbhWZS.png"></p><p><img src="https://s2.loli.net/2022/01/11/4JMvSHsQyGRjLda.png"></p><h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h3><ul><li><p><strong>数组：Array</strong>：是有序的元素序列，数组是在内存中开辟一段连续的空间，并在空间存放元素。就像酒店，有100个房间，从001到100每个房间都有固定编号，通过编号就可以迅速找到住在房间里的人。</p><p>特点：1.查询快：数组的地址是连续的，我们通过数组的首地址可以找到数组，通过数组的索引可以快速查找某一元素</p><p>​           2.增删慢：数组的长度是固定的，我们想要增加/删除一个元素，必须创建一个新数组，把源数组的数据复制过来</p></li><li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p><p><img src="https://s2.loli.net/2022/01/11/lvrotH3FVb1mnJh.png"></p></li><li><p>增删元素慢</p><p><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把元素组元素根据索引，复制到新数组对应索引的位置。</p></li></ul><p><img src="https://s2.loli.net/2022/01/11/yJTkuwC6jQAaNZh.png"></p><h3 id="4-链表"><a href="#4-链表" class="headerlink" title="4.链表"></a>4.链表</h3><ul><li><strong>链表：linked list</strong>，由一系列结点node(链表中每一个元素称为结点)组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，这里记录的是<strong>单向链表</strong>。</li></ul><p><img src="https://s2.loli.net/2022/01/11/Tx6FJyLSqnz491R.png"></p><p>简单的说，采用该结构的集合，对元素的存取有如下特点：</p><ul><li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下一个人的左手，以此类推，这样多个人就在一起了。</p><p><img src="https://s2.loli.net/2022/01/11/5XDy8YlAwfV1uFM.png"></p></li><li><p>查找元素慢：想查找某个元素，需要通过连接的结点，依次向后查找指定元素，链表中地址不是连续的，每次查询元素，都必须从头开始查询</p></li><li><p>增删元素快：链表结构，增加/删除一个元素，对链表的整体结构没有影响，所以增删快</p></li></ul><p><img src="https://s2.loli.net/2022/01/11/HBbTIjs9fdkcQxO.png"></p><h3 id="5-红黑树"><a href="#5-红黑树" class="headerlink" title="5.红黑树"></a>5.红黑树</h3><ul><li><strong>二叉树：binary tree</strong>，是每个结点不超过二的有序**树(tree)**。</li></ul><p>简单的理解，就是一种类似于我们生活中的树的结构，只不过每个结点上都最多只能有两个子结点。</p><p>二叉树是每个结点最多有两个子树的树结构。顶上：根节点，两侧：“左子树”，“右子树”。</p><ul><li><p>排序树/查找树</p><p>在二叉树的基础上，元素是有大小顺序的，左子树小，右子树大。</p><p><img src="https://s2.loli.net/2022/01/11/3EnktBm8luvs6FH.png"></p></li><li><p>平衡树</p><p><img src="https://s2.loli.net/2022/01/11/GNvTJpixAj5zgQc.png"></p></li><li><p>不平衡树</p><p><img src="https://s2.loli.net/2022/01/11/eydx2ESmpZPN17Q.png"></p></li><li><p><strong>红黑树</strong></p><p>特点：趋近于平衡树，查询的速度非常的快，查询叶子节点最大次数和最小次数不能超过二倍(找到一个元素的次数不能是其他的二倍)</p><p>性质1：每个节点要么是黑色，要么是红色。</p><p>性质2：根节点是黑色。</p><p>性质3：每个叶子节点（NIL）是黑色。</p><p>性质4：每个红色结点的两个子结点一定都是黑色。</p><p><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></p><p>性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</p><p><img src="https://s2.loli.net/2022/01/11/1fO6nDC5WqhwLNs.png"></p></li></ul><hr><h1 id="第六章-List集合"><a href="#第六章-List集合" class="headerlink" title="第六章 List集合"></a>第六章 List集合</h1><hr><h2 id="6-1List接口介绍"><a href="#6-1List接口介绍" class="headerlink" title="6.1List接口介绍"></a>6.1List接口介绍</h2><hr><p><strong>java.util.List</strong>接口继承自<strong>Collection</strong>接口，是单列集合的重要分支，实现了List接口的对象称为List集合。在List集合中允许出现重复的元素，所有元素以一种线性方式进行存储，在程序中可以通过索引来访问集合中的指定元素。List集合的特点：元素有序，即元素的存入顺序和取出顺序一致。</p><p>List接口的特点：</p><p>1.元素存取有序的集合。(存储123，取出123)</p><p>2.带索引的集合，通过索引就可以精确的操作集合中的元素。</p><p>3.集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</p><h2 id="6-2List接口中常用方法"><a href="#6-2List接口中常用方法" class="headerlink" title="6.2List接口中常用方法"></a>6.2List接口中常用方法</h2><hr><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还新增了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li>**public void add (int index,E element)**：将指定的元素，添加到该集合的指定位置上。</li><li>**public E get(int index)**：返回集合指定位置上的元素。</li><li>**public E remove(int index)**：移除列表中指定位置的元素，返回的是被移除的元素。</li><li>**public E set(int index,E element)**：用指定元素替换集合中指定位置的元素，返回值的更新前的元素。</li></ul><hr><h1 id="第七章-List的子类"><a href="#第七章-List的子类" class="headerlink" title="第七章 List的子类"></a>第七章 List的子类</h1><hr><h2 id="7-1ArrayList集合"><a href="#7-1ArrayList集合" class="headerlink" title="7.1ArrayList集合"></a>7.1ArrayList集合</h2><hr><p>​         对象数组   ：直接打印得到的是null</p><p>​         数组里放的是对象的地址值。</p><p>缺点：一旦创建，程序运行期间数组的长度不可以改变。（为了解决这个问题，我们推出了ArralyList       即长度可变的数组）</p><p><strong>ArralyList集合的概述和基本使用</strong></p><p>​     1.对于ArrayList集合来说，有一个尖括号<E>代表泛型。</p><p>​     2.泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。</p><p>​     3.注意：泛型只能是引用类型，不能是基本类型。</p><ul><li>对于ArrayList集合来说，直接打印得到的不是地址值而是内容。</li></ul><p>​       如果内容是空，得到的是空的中括号[ ]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deom02ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//创建一个集合，集合里元素的数据类型是String类型</span></span><br><span class="line"><span class="comment">//        System.out.println(list);//[]</span></span><br><span class="line">        <span class="comment">//如何向集合当中添加数据</span></span><br><span class="line">        list.add(<span class="string">&quot;西瓜&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ArralyList集合的常用方法</strong></p><ul><li><p>public boolean add(E e):向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。</p><p>备注：对于ArralyList集合来说add动作一定会成功，但是对于其他集合来说add动作不一定成功。</p></li><li><p>public E get(int index):从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。</p></li><li><p>public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。</p></li><li><p>public int size():获取集合的尺寸长度，返回值是集合当中包含的元素个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Rosy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rosy03ArrayListMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//向集合中添加元素   add 是有返回值的</span></span><br><span class="line">        <span class="keyword">boolean</span> success=list.add(<span class="string">&quot;西瓜&quot;</span>);<span class="comment">//返回值代表添加是否成功</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(success);<span class="comment">//ture</span></span><br><span class="line">        list.add(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;芒果&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;火龙果&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柚子&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;哈密瓜&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[西瓜, 苹果, 芒果, 火龙果, 柚子, 哈密瓜]</span></span><br><span class="line">        <span class="comment">//从集合中获取元素   get    索引值从0开始</span></span><br><span class="line">        String fruit=list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二号索引位置：&quot;</span>+fruit);</span><br><span class="line">        <span class="comment">//从集合中删除元素   remove 索引值从0开始</span></span><br><span class="line">        String whoremoved=list.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;被删除的元素为：&quot;</span>+whoremoved);<span class="comment">//火龙果</span></span><br><span class="line">        System.out.println(list);<span class="comment">//[西瓜, 苹果, 芒果,  柚子, 哈密瓜]</span></span><br><span class="line">        <span class="comment">//获取集合的长度尺寸，也就是其中元素的个数     size</span></span><br><span class="line">        <span class="keyword">int</span> size=list.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;此时集合的长度为：&quot;</span>+size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>遍历集合</strong></p><p>   ArralyListEach</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Rosy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RosyArrayListEach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt;list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;火龙果&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;芒果&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;哈密瓜&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;木瓜&quot;</span>);</span><br><span class="line"><span class="comment">//for循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强for循环</span></span><br><span class="line">        <span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ArrayList集合存储基本数据</strong></p><ul><li>如果希望向集合ArrayList中存储基本数据类型，必须使用基本类型对应的“包装类”。</li></ul><p>基本类型                                                   包装类（引用类型，包装类都位于java.lang包下）</p><p>byte                                                            Byte</p><p>short                                                           Short</p><p>int                                                               Integer                   【特殊】</p><p>long                                                            Long</p><p>float                                                            Float</p><p>double                                                        Double</p><p>char                                                            Character               【特殊】</p><p>boolean                                                      Boolean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Rosy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RosyArrayListBasic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; listA=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        listA.add(<span class="number">3</span>);</span><br><span class="line">        listA.add(<span class="number">8</span>);</span><br><span class="line">        listA.add(<span class="number">7</span>);</span><br><span class="line">        Iterator&lt;Integer&gt;iterator=listA.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==从jdk1.5开始，支持自动装箱拆箱==</p><p><strong>自动装箱</strong></p><p>基本数据类型自动转换为包装类型</p><p><strong>自动拆箱</strong></p><p>包装数据类型自动转换为基本类型</p><p>例一：生成六个1~33之间的随机数，并放在集合中，且遍历集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random random=<span class="keyword">new</span> Random();</span><br><span class="line">        ArrayList&lt;Integer&gt;list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r=random.nextInt(<span class="number">33</span>)+<span class="number">1</span>;</span><br><span class="line">            list.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;Integer&gt;iterator=list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2LinkedList集合"><a href="#7-2LinkedList集合" class="headerlink" title="7.2LinkedList集合"></a>7.2LinkedList集合</h2><hr><p><strong>java.util.LinkedList</strong>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><p><strong>java.util.LinkedList</strong>集合 implement List接口</p><p>LinkedList集合的特点：</p><ul><li><p>底层是一个双向链表结构，查询慢，增删快</p></li><li><p>里面包含了大量操作首尾元素的方法</p><p>注意：使用LinkedList集合特有的方法，不能使用多态</p></li></ul><blockquote><p>LinkedList是一个双向链表</p></blockquote><p><img src="https://s2.loli.net/2022/01/11/PQJCovsDIBiUqy4.png"></p><p>实际开发中对一个集合元素的增添和删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法</p><ul><li><code>public void addFirst(E e)====push()压栈</code>：将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>：将指定元素添加到此列表的结尾。</li><li><code>getFirst()       getLast()</code>：返回此列表的第一个元素/返回此列表的最后一个元素</li><li><code>removeFirst()==pop() 弹栈      removeLast()</code>：移除并返回此列表的第一个元素/移除并返回此列表的最后一个元素</li></ul><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; list01=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list01.add(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        list01.add(<span class="string">&quot;小华&quot;</span>);</span><br><span class="line">        list01.add(<span class="string">&quot;小王&quot;</span>);</span><br><span class="line">        System.out.println(list01);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        想添加【小金】到表头</span></span><br><span class="line"><span class="comment">        使用addFirst();或push();方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        list01.addFirst(&quot;小金&quot;);</span></span><br><span class="line">        list01.push(<span class="string">&quot;小金&quot;</span>);<span class="comment">//进栈</span></span><br><span class="line">        Iterator&lt;String&gt; iterator01=list01.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator01.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator01.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list01);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         想添加【小许】到表尾</span></span><br><span class="line"><span class="comment">         使用addLast();方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list01.addLast(<span class="string">&quot;小许&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator02=list01.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator02.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator02.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list01);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           返回列表的第一个和最后一个元素   getFirst();和getLast()方法</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        System.out.println(list01.getFirst());</span><br><span class="line">        System.out.println(list01.getLast());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        移除列表的第一个元素</span></span><br><span class="line"><span class="comment">        使用removeFirst();或pop();方法 弹栈</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        list01.removeFirst();</span></span><br><span class="line">        list01.pop();</span><br><span class="line">        System.out.println(list01);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        移除列表的最后一个元素</span></span><br><span class="line"><span class="comment">        使用removeLast();方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list01.removeLast();</span><br><span class="line">        System.out.println(list01);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="7-3Vector集合"><a href="#7-3Vector集合" class="headerlink" title="7.3Vector集合"></a>7.3Vector集合</h2><p>​    <code> Vector</code>  类可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。但是，<code>Vector</code>  的大小可以根据需要增大或缩小，以适应创建 <code>Vector</code> 后进行添加或移除项的操作。(了解即可)   单线程，速度慢</p><hr><h1 id="第八章-Set集合"><a href="#第八章-Set集合" class="headerlink" title="第八章 Set集合"></a>第八章 Set集合</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p><p><code>Set</code>集合有多个子类，我们介绍的是<code>java.util.HashSet</code>和<code>java.util.LinkedHashSet</code>这两个集合</p><blockquote><p>tips：Set集合取出元素的方式可以采用：迭代器、增强for。</p></blockquote><h2 id="8-1HashSet集合"><a href="#8-1HashSet集合" class="headerlink" title="8.1HashSet集合"></a>8.1HashSet集合</h2><hr><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层其实是一个<code>java.util.HashMap</code>支持。</p><p>HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此和具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>和<code>equals</code>方法</p><p>特点：</p><ul><li>不允许存储重复的元素</li><li>没有索引，没有带索引的方法，也不能使用普通的for循环遍历</li><li>是一个无序的集合，存储元素和取出元素的顺序有可能不一致</li><li>底层是一个哈希表结构(查询的速度非常的快)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11Set</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">3</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());<span class="comment">//1,2,3</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer a:set) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-2哈希表"><a href="#8-2哈希表" class="headerlink" title="8.2哈希表"></a>8.2哈希表</h2><hr><p>HashSet集合存储数据的结构</p><p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过Key值依次查找的效率较低。</p><p>在<strong>JDK1.8</strong>中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值(8)时，将链表转换为红黑树，这样大大减少了查询时间。</p><p>哈希值(Hash Code)：是一个十进制的整数，由系统随即给出(就是对象的地址值，是一个逻辑地址，是模拟出来的，不是数据实际存储的物理地址)</p><p>在Object类有一个<code>hashCode();</code>方法，返回该对象的哈希码值。</p><p>源码：public native int hashCode( );       <strong>native</strong>：代表该方法调用的是本地操作系统的方法</p><blockquote><p>tips：toString方法返回的就是哈希值的十六进制值，哈希值和toString返回的值，都不是真正物理意义上的地址值，是模拟的假的地址值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo12HashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        persion p1=<span class="keyword">new</span> persion();</span><br><span class="line">        persion p2=<span class="keyword">new</span> persion();</span><br><span class="line">        <span class="keyword">int</span> code1 = p1.hashCode();</span><br><span class="line">        <span class="keyword">int</span> code2 = p2.hashCode();</span><br><span class="line">        System.out.println(code1);<span class="comment">//重写前：460141958     重写后：1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        System.out.println(code2);<span class="comment">//重写前：1163157884    重写后：1</span></span><br><span class="line">        System.out.println(p1);<span class="comment">//重写前：Demo02.persion@1b6d3586  重写后：Demo02.persion@1</span></span><br><span class="line">        System.out.println(p2);<span class="comment">//重写前：Demo02.persion@4554617c  重写后：Demo02.persion@1</span></span><br><span class="line">        System.out.println(p1==p2);<span class="comment">//false  即真正意义上的地址值不相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     1b6d3586(十六进制)---&gt;(十进制)460141958</span></span><br><span class="line"><span class="comment">     4554617c(十六进制)---&gt;(十进制)1163157884</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">persion</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    return super.hashCode();源码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//重写hashCode方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips：String类里重写了hashCode方法</p></blockquote><p><strong>hashCode</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode()</span><br></pre></td></tr></table></figure><p>返回此字符串的哈希码。String 对象的哈希码根据以下公式计算： </p><p> **s[0]<em>31^(n-1) + s[1]<em>31^(n-2) + … + s[n-1]</em></em></p><p> <strong>使用 int 算法</strong>，这里 s[i] 是字符串的第 i 个字符，n 是字符串的长度，^ 表示求幂。（空字符串的哈希值为 0。）</p><hr><p><strong>哈希冲突</strong></p><p>两个元素不同，但是哈希值相同</p><p><img src="https://s2.loli.net/2022/01/11/gkRGWCfBNmIUXvZ.png"></p><p>数组超过8位</p><p>少6变回数组</p><p>解决办法：</p><ul><li>拉链法</li><li>开放寻址</li></ul><h2 id="8-3Set集合存储元素不重复原理"><a href="#8-3Set集合存储元素不重复原理" class="headerlink" title="8.3Set集合存储元素不重复原理"></a>8.3Set集合存储元素不重复原理</h2><hr><p>哈希表中，没有重复元素的原因：集合在调用add方法时，add方法会调用元素的hashCode方法和equals方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo13HashSetSaveString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        String s1=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        String s2=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        set.add(s1);</span><br><span class="line">        set.add(s2);</span><br><span class="line">        set.add(<span class="string">&quot;重地&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;通话&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(set);<span class="comment">//[重地, 通话, abc]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/01/11/DP92zZ1wRh5vnAg.png"></p><hr><h2 id="8-4HashSet存储自定义类型元素"><a href="#8-4HashSet存储自定义类型元素" class="headerlink" title="8.4HashSet存储自定义类型元素"></a>8.4HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo14HashSetSavePersion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;persions&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        persions p1=<span class="keyword">new</span> persions(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        persions p2=<span class="keyword">new</span> persions(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        persions p3=<span class="keyword">new</span> persions(<span class="string">&quot;小明&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line">        System.out.println(p1.hashCode());<span class="comment">//hashCode和equals方法重写前：460141958</span></span><br><span class="line">        <span class="comment">//重写后：23458775</span></span><br><span class="line">        System.out.println(p2.hashCode());<span class="comment">//hashCode和equals方法重写前：1163157884</span></span><br><span class="line">        <span class="comment">//重写后：23458775</span></span><br><span class="line">        System.out.println(p1==p2);<span class="comment">//hashCode和equals方法重写前：false</span></span><br><span class="line">        <span class="comment">//重写后：false</span></span><br><span class="line">        System.out.println(p1.equals(p2));<span class="comment">//hashCode和equals方法重写前：false</span></span><br><span class="line">        <span class="comment">//重写后：true</span></span><br><span class="line">        System.out.println(set);<span class="comment">//hashCode和equals方法重写前：[persions&#123;name=&#x27;小明&#x27;, age=24&#125;, persions&#123;name=&#x27;小明&#x27;, age=21&#125;, persions&#123;name=&#x27;小明&#x27;, age=21&#125;]</span></span><br><span class="line">        <span class="comment">//重写后：[persions&#123;name=&#x27;小明&#x27;, age=21&#125;, persions&#123;name=&#x27;小明&#x27;, age=24&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">persions</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">persions</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        persions persions = (persions) o;</span><br><span class="line">        <span class="keyword">return</span> age == persions.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, persions.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;persions&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-5LinkedHashSet"><a href="#8-5LinkedHashSet" class="headerlink" title="8.5LinkedHashSet"></a>8.5LinkedHashSet</h2><hr><p>我们知道HashSet保证元素唯一，但是元素存进去是没有顺序的，要保证有序如何实现。</p><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><p>代码演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo15LinkedHashSet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set=<span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator=set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  具有可预知迭代顺序的 <code>Set</code> 接口的哈希表和链接列表实现。此实现与 <code>HashSet</code>  的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，即按照将元素插入到 set  中的顺序（<em>插入顺序</em>）进行迭代。注意，插入顺序<em>不</em> 受在 set 中<em>重新插入的</em> 元素的影响。（如果在  <code>s.contains(e)</code> 返回 <code>true</code> 后立即调用 <code>s.add(e)</code>，则元素 <code>e</code>  会被重新插入到 set <code>s</code> 中。） </p><p>  此实现可以让客户免遭未指定的、由HashSet提供的通常杂乱无章的排序工作，而又不致引起与TreeSet关联的成本增加。使用它可以生成一个与原来顺序相同的 set 副本，并且与原 set 的实现无关： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo(Set s) &#123;</span><br><span class="line">    Set copy = new LinkedHashSet(s);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果模块通过输入得到一个 set，复制这个  set，然后返回由此副本决定了顺序的结果，这种情况下这项技术特别有用。（客户通常期望内容返回的顺序与它们出现的顺序相同。） </p><p>  此类提供所有可选的 <code>Set</code> 操作，并且允许 null 元素。与 <code>HashSet</code>  一样，它可以为基本操作（<code>add</code>、<code>contains</code> 和  <code>remove</code>）提供稳定的性能，假定哈希函数将元素正确地分布到存储段中。由于增加了维护链接列表的开支，其性能很可能会比  <code>HashSet</code> 稍逊一筹，不过，这一点例外：<code>LinkedHashSet</code> 迭代所需时间与 set 的<em>大小</em>  成正比，而与容量无关。<code>HashSet</code> 迭代很可能支出较大，因为它所需迭代时间与其<em>容量</em> 成正比。 </p><p>  链接的哈希 set 有两个影响其性能的参数：<em>初始容量</em> 和<em>加载因子</em>。它们与 <code>HashSet</code>  中的定义极其相同。注意，为初始容量选择非常高的值对此类的影响比对 <code>HashSet</code> 要小，因为此类的迭代时间不受容量的影响。 </p><p>  <strong>注意，此实现不是同步的。</strong>如果多个线程同时访问链接的哈希 set，而其中至少一个线程修改了该  set，则它<em>必须</em> 保持外部同步。这一般通过对自然封装该 set 的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedSet方法来“包装”该 set。最好在创建时完成这一操作，以防止意外的非同步访问： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set s = Collections.synchronizedSet(new LinkedHashSet(...));</span><br></pre></td></tr></table></figure><p>此类的 <code>iterator</code> 方法返回的迭代器是<em>快速失败</em> 的：在迭代器创建之后，如果对 set  进行修改，除非通过迭代器自身的 <code>remove</code> 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException，因此，面对并发的修改，迭代器很快就会完全失败，而不冒将来不确定的时间任意发生不确定行为的风险。 </p><p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在不同步的并发修改时，不可能作出任何强有力的保证。快速失败迭代器尽最大努力抛出  <code>ConcurrentModificationException</code>。因此，编写依赖于此异常的程序的方式是错误的，正确做法是：<em>迭代器的快速失败行为应该仅用于检测程序错误。</em> </p><p>此类是 <a href="../../../technotes/guides/collections/index.html">Java  Collections Framework</a> 的成员。 </p><h2 id="8-6-可变参数"><a href="#8-6-可变参数" class="headerlink" title="8.6 可变参数"></a>8.6 可变参数</h2><hr><blockquote><p>tips：当使用参数类型确定，而个数不确定时，可以使用可变参数</p></blockquote><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><p><code>修饰符 返回值类型 方法名(参数类型...形参名)&#123;  &#125;</code></p><p>等价于</p><p><code>修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</code></p><p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p><p><strong>JDK1.5</strong>以后。出现了简化操作。…用在参数上，称之为可变参数。</p><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p><p><strong>原理：</strong>可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数，传递的参数个数，可以是0个(不传递)，1，2. . .多个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16VarArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int i = add();</span></span><br><span class="line"><span class="comment">//        System.out.println(i);[I @1b6d3586  [代表数组        I代表int类型</span></span><br><span class="line">        <span class="keyword">int</span> s=add(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>);</span><br><span class="line">        System.out.println(s);<span class="comment">//100</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>...arr)</span></span>&#123;</span><br><span class="line">        System.out.println(arr.length);<span class="comment">//4</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:arr) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：1.一个方法的参数列表，只能有一个可变参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    public static void method(int...a,String...b)&#123;  会报错</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String...b)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                  2.如果方法的参数有多个，那么可变参数必须写在参数列表的末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    public static void method(int...i,int a,String b,double c)&#123;  会报错</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String b,<span class="keyword">int</span> a,<span class="keyword">double</span> c,<span class="keyword">int</span>...i)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="第九章-Collections"><a href="#第九章-Collections" class="headerlink" title="第九章 Collections"></a>第九章 Collections</h1><hr><h2 id="9-1常用功能"><a href="#9-1常用功能" class="headerlink" title="9.1常用功能"></a>9.1常用功能</h2><hr><ul><li><code>java.util.Collections</code>是集合工具类，用来对集合进行操作，部分方法如下：</li><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c,T... elements)</code>：向集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list)</code>：打乱集合元素的顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>：将集合中元素按照默认规则排序</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt;)</code>：将集合中元素按照指定规则排序</li></ul><blockquote><p>tips：sort(List<T> list)使用前提：被排序的集合里的元素，必须实现Comparable，重写接口中的方法comparTo定义排序的规则</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo17Collections</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        向集合中添加多个元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[a, b, c, d, e]</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        打乱集合中元素的顺序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        集合中元素按照默认方式排序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Collections.sort(list);<span class="comment">//默认是升序</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        集合中元素按照指定方式排序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义类型</strong></p><p>Comparable接口的排序顺序：</p><p>自己(this)-参数：升序</p><p>参数-自己(this)：降序</p><p><strong>Comparator和Comparable的区别</strong></p><p>Comparable:自己(this )和别人(参数)比较,自己需要实现comparable接口,重写比较的规则compareTo方法</p><p>Comparator:相当于找—个第三方的裁判,比较两个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo18Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Persion&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Persion(<span class="string">&quot;小明&quot;</span>,<span class="number">21</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Persion(<span class="string">&quot;a小李&quot;</span>,<span class="number">19</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Persion(<span class="string">&quot;小张&quot;</span>,<span class="number">29</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Persion(<span class="string">&quot;b小王&quot;</span>,<span class="number">19</span>));</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);<span class="comment">//[Persion&#123;name=&#x27;小明&#x27;, age=21&#125;, Persion&#123;name=&#x27;小李&#x27;, age=22&#125;, Persion&#123;name=&#x27;小张&#x27;, age=29&#125;, Persion&#123;name=&#x27;小王&#x27;, age=19&#125;]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Persion&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Persion o1, Persion o2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//                return o1.getAge()-o2.getAge();按年龄升序排序</span></span><br><span class="line"><span class="comment">//                return o2.getAge()-o1.getAge();按年龄降序排序</span></span><br><span class="line">                <span class="keyword">int</span> result=o1.getAge()-o2.getAge();<span class="comment">//按年龄升序排序</span></span><br><span class="line">                <span class="keyword">if</span>(result==<span class="number">0</span>)&#123;</span><br><span class="line">                    result= o1.getName().charAt(<span class="number">0</span>)-o2.getName().charAt(<span class="number">0</span>);<span class="comment">//首字母排序</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persion</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Persion</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Persion&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//重写排序规则</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Persion o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//认为元素都是相同的</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        可以自定义比较方法 比较两人的年龄(this,参数Person)</span></span><br><span class="line"><span class="comment">        return this.getAge()-o.getAge()//按年龄升序排序</span></span><br><span class="line"><span class="comment">        return o.getAge()-this.getAge()//按年龄降序排序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第十章-Map集合-双列集合"><a href="#第十章-Map集合-双列集合" class="headerlink" title="第十章 Map集合(双列集合)"></a>第十章 Map集合(双列集合)</h1><hr><h2 id="10-1概述"><a href="#10-1概述" class="headerlink" title="10.1概述"></a>10.1概述</h2><p>前几章我们学习的都是单列集合，而Map是双列集合。</p><p>Map&lt;K,V&gt;，K我们称为键(此映射所维护的键的类型)，V我们称为值(映射值的类型)，键是不允许重复的，value可以重复。</p><blockquote><p>tips：Map集合中K和V的关系类似于函数自变量和函数值的关系。</p></blockquote><p>在现实生活中，我们常会看到这样一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><p>对比Collection接口与Map接口的不同：</p><p><img src="https://s2.loli.net/2022/01/11/ERZUXqpTtaWLbJe.png"></p><h2 id="10-2Map常用子类"><a href="#10-2Map常用子类" class="headerlink" title="10.2Map常用子类"></a>10.2Map常用子类</h2><hr><ul><li><p><strong>HashMap</strong>&lt;K,V&gt;：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</p><p><code>java.util.HashMap&lt;K,V&gt;集合 implements Map&lt;K,V&gt;接口</code></p><p>特点：1. HashMap集合底层是哈希表：查询速度特别快</p><p>​                       JDK1.8之前：数组+单向链表</p><p>​                       JDK1.8之后：数组+单向链表/红黑树(当链表长度超过8)：提高查询的速度</p><p>​           2.HashMap集合是一个无序的集合，存储元素和取出元素的顺序有可能不一致</p></li><li><p><strong>LinkedHashMap</strong>&lt;K,V&gt;：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</p><p><code>java.util.LinkedHashMap&lt;K,V&gt;集合 extends HashMap&lt;K,V&gt;集合</code></p><p>特点：1. LinkedHashMap集合底层是哈希表+链表(保证迭代的顺序)</p><p>​           2.LinkedHashMap集合是一个有序的集合，存储元素和取出元素的顺序是一致的</p></li></ul><blockquote><p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;，在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p></blockquote><h2 id="10-3Map接口中的常用方法"><a href="#10-3Map接口中的常用方法" class="headerlink" title="10.3Map接口中的常用方法"></a>10.3Map接口中的常用方法</h2><hr><ul><li><p><code>public V put(k Key,V value)</code>：把指定的键与指定的值添加到Map集合中</p><p>返回值：V</p><p>​      存储时，Key不重复，返回值V时null</p><p>​      存储时，Key重复，会使用新的value替换Map中重复的value，返回被替换的value值</p></li><li><p><code>public V remove(Object key)</code>：把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</p><p>返回值：V</p><p>​      Key存在，V返回被删除的值</p><p>​      Key不存在，V返回null</p></li><li><p><code>public V get(Object Key)</code>：根据指定的键，在Map集合中获取对应的值。</p><p>返回值：V</p><p>​       Key存在，V返回该K对应的值</p><p>​       Key不存在，V返回null</p></li><li><p><code>boolean containsKey(Object Key)</code>：判断集合中是否包含指定的键。</p><p>​       Key存在，返回true</p><p>​       Key不存在，返回false</p></li><li><p><code>public Set&lt;K&gt; KeySet()</code>：获取Map集合中所有的键，存储到Set集合中。</p></li><li><p><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取到Map集合中所有的键值对对象的集合(Set集合)。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Map</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//      show01();</span></span><br><span class="line"><span class="comment">//      show02();</span></span><br><span class="line">        show03();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：获取到Map集合中所有的键值对对象的集合(Set集合)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; map03= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map03.put(<span class="string">&quot;小明&quot;</span>,<span class="number">176</span>);</span><br><span class="line">        map03.put(<span class="string">&quot;小华&quot;</span>,<span class="number">178</span>);</span><br><span class="line">        map03.put(<span class="string">&quot;小金&quot;</span>,<span class="number">169</span>);</span><br><span class="line">        map03.put(<span class="string">&quot;小林&quot;</span>,<span class="number">183</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        boolean containsKey(Object Key)：判断集合中是否包含指定的键。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> b1 = map03.containsKey(<span class="string">&quot;小金&quot;</span>);</span><br><span class="line">        System.out.println(b1);<span class="comment">//true</span></span><br><span class="line">        <span class="keyword">boolean</span> b2 = map03.containsKey(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        System.out.println(b2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(map03);<span class="comment">//&#123;小林=183, 小明=176, 小华=178, 小金=169&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map03.entrySet();</span><br><span class="line">        System.out.println(set);<span class="comment">//[小林=183, 小明=176, 小华=178, 小金=169]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public V remove(Object key)：把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; map02= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map02.put(<span class="string">&quot;小明&quot;</span>,<span class="number">87</span>);</span><br><span class="line">        map02.put(<span class="string">&quot;小华&quot;</span>,<span class="number">97</span>);</span><br><span class="line">        map02.put(<span class="string">&quot;小金&quot;</span>,<span class="number">87</span>);</span><br><span class="line">        map02.put(<span class="string">&quot;小林&quot;</span>,<span class="number">99</span>);</span><br><span class="line">        System.out.println(map02);</span><br><span class="line">        Integer a1 = map02.remove(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        System.out.println(a1);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">        Integer a2 = map02.remove(<span class="string">&quot;小金&quot;</span>);</span><br><span class="line">        System.out.println(a2);<span class="comment">//87</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public V get(Object Key)：根据指定的键，在Map集合中获取对应的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Integer a3 = map02.get(<span class="string">&quot;小林&quot;</span>);</span><br><span class="line">        System.out.println(a3);<span class="comment">//99</span></span><br><span class="line">        Integer a4 = map02.get(<span class="string">&quot;小琳&quot;</span>);</span><br><span class="line">        System.out.println(a4);<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public V put(k Key,V value)：把指定的键与指定的值添加到Map集合中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;String,String&gt; map01= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        String s1 = map01.put(<span class="string">&quot;计算机&quot;</span>, <span class="string">&quot;鼠标&quot;</span>);</span><br><span class="line">        System.out.println(s1);<span class="comment">//null</span></span><br><span class="line">        String s2 = map01.put(<span class="string">&quot;计算机&quot;</span>, <span class="string">&quot;键盘&quot;</span>);</span><br><span class="line">        System.out.println(s2);<span class="comment">//鼠标   返回的是被替换的值</span></span><br><span class="line">        map01.put(<span class="string">&quot;硬件&quot;</span>,<span class="string">&quot;软件&quot;</span>);</span><br><span class="line">        map01.put(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        map01.put(<span class="string">&quot;C&quot;</span>,<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        System.out.println(map01);<span class="comment">//&#123;java=C++, C=C++, 硬件=软件, 计算机=键盘&#125;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public Set&lt;K&gt; KeySet()：获取Map集合中所有的键，存储到Set集合中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; set = map01.keySet();</span><br><span class="line">        System.out.println(set);<span class="comment">//[java, C, 硬件, 计算机]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-4-Map集合遍历键找值方式"><a href="#10-4-Map集合遍历键找值方式" class="headerlink" title="10.4 Map集合遍历键找值方式"></a>10.4 Map集合遍历键找值方式</h2><hr><p>键找值方式：即通过元素中的键，获取键所在的值</p><p>分析步骤：</p><p>1.获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示<code>KeySet()</code></p><p>2.遍历键的Set集合，得到每一个键</p><p>3.根据键，获取键所对应的值。方法提示<code>get(K key)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02KeySet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       show01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;小明&quot;</span>, <span class="number">176</span>);</span><br><span class="line">        map.put(<span class="string">&quot;小华&quot;</span>, <span class="number">178</span>);</span><br><span class="line">        map.put(<span class="string">&quot;小金&quot;</span>, <span class="number">169</span>);</span><br><span class="line">        map.put(<span class="string">&quot;小林&quot;</span>, <span class="number">183</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public Set&lt;K&gt; KeySet()：获取Map集合中所有的键，存储到Set集合中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        System.out.println(set);<span class="comment">//[小林, 小明, 小华, 小金]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">       迭代器遍历集合</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Iterator&lt;String&gt; iterator=set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            增强for</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (String Key:set) &#123;</span><br><span class="line">                Integer integer01 = map.get(Key);<span class="comment">//通过Key找Value</span></span><br><span class="line">                System.out.println(integer01);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String Key:map.keySet()) &#123;</span><br><span class="line">                Integer integer02 = map.get(Key);<span class="comment">//通过Key找Value</span></span><br><span class="line">                System.out.println(integer02);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-5Entry键值对对象"><a href="#10-5Entry键值对对象" class="headerlink" title="10.5Entry键值对对象"></a>10.5Entry键值对对象</h2><hr><p>Map中存放的是两种对象，一种称为<strong>Key</strong>(键)，一种称为<strong>value</strong>(值)，它们在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对(Entry)对象中获取对应的键和对应的值。</p><p>获取对应的键和对应的值的方法：</p><ul><li><code>public K getKey( )</code>：获取Entry对象中的键。</li><li><code>public V getValue( )</code>：获取Entry对象中的值。</li></ul><p>获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取到Map集合中所有的键值对对象的集合(Set集合)</li></ul><h2 id="10-6Map集合遍历键值对方式"><a href="#10-6Map集合遍历键值对方式" class="headerlink" title="10.6Map集合遍历键值对方式"></a>10.6Map集合遍历键值对方式</h2><hr><p>步骤：</p><p>1.使用Map集合中的方法entrySet()，把Map集合中多个Entry对象取出来，存储到一个Set集合中</p><p>2.遍历Set集合，获取每一个Entry对象</p><p>3.使用Entry对象中的方法getKey()和getValue()获取键与值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyStore;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03EntrySet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       show01();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;小明&quot;</span>,<span class="number">87</span>);</span><br><span class="line">        map.put(<span class="string">&quot;小华&quot;</span>,<span class="number">97</span>);</span><br><span class="line">        map.put(<span class="string">&quot;小金&quot;</span>,<span class="number">87</span>);</span><br><span class="line">        map.put(<span class="string">&quot;小林&quot;</span>,<span class="number">99</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line">        System.out.println(set);<span class="comment">//[小林=99, 小明=87, 小华=97, 小金=87]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; iterator=set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String,Integer&gt; entry01=iterator.next();</span><br><span class="line">            String key01 = entry01.getKey();</span><br><span class="line">            Integer value01 = entry01.getValue();</span><br><span class="line">            System.out.println(key01+<span class="string">&quot;=&quot;</span>+value01);</span><br><span class="line"><span class="comment">//            小林=99</span></span><br><span class="line"><span class="comment">//            小明=87</span></span><br><span class="line"><span class="comment">//            小华=97</span></span><br><span class="line"><span class="comment">//            小金=87</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            通过增强for</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String,Integer&gt; entry02:set) &#123;</span><br><span class="line">                String key02 = entry02.getKey();</span><br><span class="line">                Integer value02 = entry02.getValue();</span><br><span class="line">                System.out.println(key02+<span class="string">&quot;=&quot;</span>+value02);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-7HashMap存储自定义类型键值"><a href="#10-7HashMap存储自定义类型键值" class="headerlink" title="10.7HashMap存储自定义类型键值"></a>10.7HashMap存储自定义类型键值</h2><hr><p>练习：每位学生(姓名，年龄)都有自己的家庭地址。那么，既然有对应关系，则将学生对象和家庭住址存储到Map集合中。学生作为键，家庭住址作为值。</p><blockquote><p>tips：学生姓名相同并且年龄相同视为同一名学生</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.tree.analysis.Value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04HashMapSavePerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//      show01();</span></span><br><span class="line">        show02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;Student,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>,<span class="number">18</span>),<span class="number">178</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;小李&quot;</span>,<span class="number">19</span>),<span class="number">175</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;小林&quot;</span>,<span class="number">20</span>),<span class="number">179</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;小金&quot;</span>,<span class="number">18</span>),<span class="number">183</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;小笠&quot;</span>,<span class="number">18</span>),<span class="number">178</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;小笠&quot;</span>,<span class="number">18</span>),<span class="number">178</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;Student, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Student,Integer&gt; a:set) &#123;</span><br><span class="line">            Integer value = a.getValue();</span><br><span class="line">            Student key = a.getKey();</span><br><span class="line">            System.out.println(key+<span class="string">&quot;----&gt;&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   HashMap存储自定义类型键值</span></span><br><span class="line"><span class="comment">   key : string类型</span></span><br><span class="line"><span class="comment">         string类重写hashcode方法和equals方法,可以保证key唯一</span></span><br><span class="line"><span class="comment">   value : Person类型</span></span><br><span class="line"><span class="comment">    value可以重复(同名同年龄的人视为同一个)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;String,Student&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;北京&quot;</span>,<span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        map.put(<span class="string">&quot;上海&quot;</span>,<span class="keyword">new</span> Student(<span class="string">&quot;小李&quot;</span>,<span class="number">19</span>));</span><br><span class="line">        map.put(<span class="string">&quot;北票&quot;</span>,<span class="keyword">new</span> Student(<span class="string">&quot;小林&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        map.put(<span class="string">&quot;沈阳&quot;</span>,<span class="keyword">new</span> Student(<span class="string">&quot;小金&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        map.put(<span class="string">&quot;哈尔滨&quot;</span>,<span class="keyword">new</span> Student(<span class="string">&quot;小笠&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        map.put(<span class="string">&quot;哈尔滨&quot;</span>,<span class="keyword">new</span> Student(<span class="string">&quot;小笠&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String Key: set) &#123;</span><br><span class="line">            Student value=map.get(Key);</span><br><span class="line">            System.out.println(Key+<span class="string">&quot;---&gt;&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-7LinkedHashMap"><a href="#10-7LinkedHashMap" class="headerlink" title="10.7LinkedHashMap"></a>10.7LinkedHashMap</h2><hr><p>HashMap保证元素唯一，并且查询速度很快，可是我们要保证元素有序，还要速度快，就要了解LinkedHashMap，它是HashMap下面有一个子类，它是链表和哈希表组合的一个数据存储结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05LinkedHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show01();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LinkedHashMap&lt;String,Integer&gt; map=<span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;小明&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        map.put(<span class="string">&quot;小李&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        map.put(<span class="string">&quot;小林&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry:set) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">&quot;---&gt;&quot;</span>+value);</span><br><span class="line"><span class="comment">//            小明---&gt;18</span></span><br><span class="line"><span class="comment">//            小李---&gt;20</span></span><br><span class="line"><span class="comment">//            小林---&gt;18</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-8Hashtable集合"><a href="#10-8Hashtable集合" class="headerlink" title="10.8Hashtable集合"></a>10.8Hashtable集合</h2><hr><p>Hashtable&lt;k,v&gt; implements Map&lt;K,V&gt;   双列集合(<strong>JDK1.0</strong>)比较早</p><p>此类实现了一个哈希表，该哈希表将键映射到相应的值。任何非null对象都可以用做键或值。Hashtable是同步的(单线程)：速度慢</p><ul><li><p>HashtabLe:底层也是一个哈希表,是一个线程安全的集合,是单线程集合,速度慢，不能存储null值, null键</p></li><li><p>HashMap:底层是一个哈希表,是一个线程不安全的集合,是多线程的集合,速度快，可以存储null值, null键</p></li></ul><p>Hashtable和vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap , ArrdyList)取代了</p><p>HashtabLe的子类Properties依然活跃在历史舞台          <strong>Properties集合是一个唯—和I0流相结合的集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05Hashtable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//      show02();</span></span><br><span class="line">        show01();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">null</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;null=null, a=null&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Hashtable&lt;String,String&gt; hashtable=<span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">        hashtable.put(<span class="keyword">null</span>,<span class="string">&quot;a&quot;</span>);<span class="comment">//NullPointerException</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;a&quot;</span>,<span class="keyword">null</span>);<span class="comment">//NullPointerException</span></span><br><span class="line">        hashtable.put(<span class="keyword">null</span>,<span class="keyword">null</span>);<span class="comment">//NullPointerException</span></span><br><span class="line">        System.out.println(hashtable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-9Map集合练习"><a href="#10-9Map集合练习" class="headerlink" title="10.9Map集合练习"></a>10.9Map集合练习</h2><hr><p><strong>需求：</strong></p><p>计算一个字符串中每个字符出现次数</p><p><strong>分析</strong></p><p>​    1.获取一个字符串对象</p><p>​    2.创建一个Map集合，键代表字符，值代表次序</p><p>​    3.遍历字符串得到每个字符</p><p>​    4.判断Map中是否有该键</p><p>​    5.如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储</p><p>​    6.打印最终结果</p><p>分析:</p><p>1.使用scanner获取用户输入的字符串</p><p>2.创建Map集合,key是字符串中的字符, value是字符的个数</p><p>3.遍历字符串,获取每一个字符</p><p>4.使用获取到的字符,去Nap集合判断key是否存在</p><p>key存在:  通过字符(key) ,获取value(字符个数)value++     put( key , value)把新的vatue存储到Map集合中</p><p>key不存在:  put( key ,1)</p><p>5.遍历Map集合,输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      show01();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">        String s=in.next();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c))&#123;</span><br><span class="line">                Integer value = map.get(c);</span><br><span class="line">                value++;</span><br><span class="line">                map.put(c,value);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Character Key:map.keySet()) &#123;</span><br><span class="line">            Integer value = map.get(Key);</span><br><span class="line">            System.out.println(Key+<span class="string">&quot;---&gt;&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-10JDK9对集合添加的优化"><a href="#10-10JDK9对集合添加的优化" class="headerlink" title="10.10JDK9对集合添加的优化"></a>10.10JDK9对集合添加的优化</h2><hr><p>添加元素时，List和Set集合使用add方法，Map集合使用put方法</p><p>在<strong>JDK9</strong>时，新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p><p><strong>of方法</strong>(了解即可)</p><hr><h1 id="附加：Debug追踪"><a href="#附加：Debug追踪" class="headerlink" title="附加：Debug追踪"></a>附加：Debug追踪</h1><hr><p><strong>Debug调试程序：</strong></p><p>​        可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug。</p><p><strong>使用方式：</strong></p><p>​        在行号的右边，鼠标左键单击，添加断点(每个方法的第一行，哪里有bug添加到哪里)</p><p>​        右键，选择Debug执行程序</p><p>​        程序就会停留在添加的第一个断点处</p><p><strong>执行程序：</strong></p><p>​         f8：逐行执行程序</p><p>​         f7：进入到方法中</p><p>​         shift+f8：跳出方法</p><p>​         f9：跳到下一个断点，如果没有下一个断点，那么就借书程序</p><p>​         ctrl+f2：退出debug模式，停止程序</p><p>​         Console：切换到控制台</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;第一章-Collection集合-单列集合&quot;&gt;&lt;a href=&quot;#第一章-Collection集合-单列集合&quot; class=&quot;headerlink&quot; title=&quot;第一章 Collection集合(单列集合)&quot;&gt;&lt;/a&gt;第一章 Collection集合(</summary>
      
    
    
    
    <category term="java" scheme="https://www.stq555.com/categories/java/"/>
    
    
    <category term="java" scheme="https://www.stq555.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>留言功能上线~</title>
    <link href="https://www.stq555.com/2022/01/10/%E7%95%99%E8%A8%80%E5%8A%9F%E8%83%BD%E4%B8%8A%E7%BA%BF/"/>
    <id>https://www.stq555.com/2022/01/10/%E7%95%99%E8%A8%80%E5%8A%9F%E8%83%BD%E4%B8%8A%E7%BA%BF/</id>
    <published>2022-01-09T17:05:15.000Z</published>
    <updated>2022-01-09T17:07:49.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Valine留言功能上线"><a href="#Valine留言功能上线" class="headerlink" title="Valine留言功能上线~"></a>Valine留言功能上线~</h2><p>欢迎大家来评论</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Valine留言功能上线&quot;&gt;&lt;a href=&quot;#Valine留言功能上线&quot; class=&quot;headerlink&quot; title=&quot;Valine留言功能上线~&quot;&gt;&lt;/a&gt;Valine留言功能上线~&lt;/h2&gt;&lt;p&gt;欢迎大家来评论&lt;/p&gt;
</summary>
      
    
    
    
    <category term="First" scheme="https://www.stq555.com/categories/First/"/>
    
    
    <category term="留言" scheme="https://www.stq555.com/tags/%E7%95%99%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>README</title>
    <link href="https://www.stq555.com/2022/01/08/README/"/>
    <id>https://www.stq555.com/2022/01/08/README/</id>
    <published>2022-01-08T14:05:55.000Z</published>
    <updated>2022-01-09T17:42:34.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="README"><a href="#README" class="headerlink" title="README"></a>README</h1><p>说明：因为假期的原因，想试着搭一个属于自己的博客，会在这里发一些每天学习的知识，或是遇到的有意思的事，希望可以和大家相互交流，一起进步。</p><p>博客仅用于学习和交流。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;README&quot;&gt;&lt;a href=&quot;#README&quot; class=&quot;headerlink&quot; title=&quot;README&quot;&gt;&lt;/a&gt;README&lt;/h1&gt;&lt;p&gt;说明：因为假期的原因，想试着搭一个属于自己的博客，会在这里发一些每天学习的知识，或是遇到的有意思的事，希望可</summary>
      
    
    
    
    <category term="First" scheme="https://www.stq555.com/categories/First/"/>
    
    
    <category term="The One Day" scheme="https://www.stq555.com/tags/The-One-Day/"/>
    
  </entry>
  
</feed>
